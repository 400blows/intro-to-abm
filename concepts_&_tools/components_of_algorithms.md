# Components of Algorithms

We will now discuss a number of concepts that are used in developing algorithms.

##If then else
In everyday situations you have many different choices to make. If the traffic light is green you cross the street, otherwise you wait. If you want to send a letter, you mail it with sufficient stamps, otherwise the letter will not reach the destination.


In programs we have many of these situations too, which are stated more formally as IF a condition is true THEN do this ELSE do that. This procedure is used to let algorithms do tasks that are dependent on the state of the system. For example, an agent will move randomly except when the agent sees food on the cell in front of itself. In this case the agent will move forward. In this example the situation is stated

IF food on next cell THEN move forward ELSE move randomly.

Another example shows how you can avoid dividing by zero. Given are variable x, and parameters a and b.

IF a = 0 THEN x = b / a ELSE write “division by zero”
Where = means “not equal to.”

For example, in bubble sort, you can have the following use of if then else:


```
IF a > b THEN
     c = b<br>
     b = a<br>
     a = c<br>
ELSE
     a = a
     b = b```

where a and b are two items in the list that are swapped if a > b.

##Boolean
This is a variable that is defined to be FALSE or TRUE.

A boolean variable has only two possible values, TRUE or FALSE. This means that if a variable x is not TRUE, it will be FALSE.

Suppose x is FALSE. What is the value of a in the following statement?
```
IF x THEN a=2 ELSE a=1```

Since x is FALSE, a is equal to 1.

##While loop
Sometimes you want to repeat a set of commands until a particular condition is met. For example, you are searching through a list of numbers until you find a particular value. You move to the next item in the list until you find the item you are looking for. You can implement this by using *while loops*.

Using the search example you can implement this as follows

```
position 1
WHILE a != seacha
{
       a = list [position]
       position = position + 1
```

where seacha is the value looked for. Recall that = means “unequal to.” One moves through the list, looking at the value of each item until seacha is found.

What will be the value of X in the following while loop?

```
A 1
WHILE A < 10
        X = A * 2
        A = A + 2
        ```
Answer, X will have the values 2, 6, 10, 14, 18 and then the while loop will be ended.

##Recursion
Recursion implies a procedure that calls itself and it is commonly used in computer programs. A simple example is to calculate n! by the following procedure *factorial*
```
Factorial[N]
       IF N <=1 THEN fact = 1 ELSE fact = N * factorial[N-1]
       ```

Thus if we want to calculate 4!, we will start with Factorial[4]

Factorial[4] leads to fact = 4 \* Factorial[3]<br>
Factorial[3] leads to fact = 3 \* Factorial[2]<br>
Factorial[2] leads to fact = 2 \* Factorial[1]<br>
Factorial[1] leads to fact = 1<br>

Then it jumps back to finish Factorial[2]: fact = 2 \* 1 = 2<br>
Then it jumps back to finish Factorial[3]: fact = 3 \* 2 = 6<br>
Finally it can finish Factorial[4]: fact = 4 \* 6 = 24

Thus 4! = 24<br>

##Random numbers
Random numbers in simulation models are not truly random. Rather, they are generated by so-called [random number generators](http://en.wikipedia.org/wiki/Random_number_generation). In fact, the functions used to generate random numbers are deterministic and may therefore repeat the same sequence after tens of thousands of “random numbers.”
An example is the [linear congruential generator](http://en.wikipedia.org/wiki/Linear_congruential_generator) that generates sequences of numbers x by using the next equation:
```
x(t+1)=(A*x(t)+B) mod M
```
where the A, B and M are pre-selected constants. Note that M represents the upper level of the sequence of random numbers. A and B are defined in such a way that they meet desirable statistical properties. An example which is commonly used is A = 1664525, B = 1013904223, M = 32. Another number that needs to be specific is the seed, which is the value of x at the start of the sequence.

Suppose you start with x = 1, then the next step we get
```
x = (1664525 * 1 + 1013904223) mod 32
```
Since mod means modulo which finds the remainder of division of one number by another we get
```
x = 1015568748 mod 32 = 12
```
If we continue we get the sequence 1, 12, 27, 30, 5, 0, 31, 18, 9, 20, 3, …


Any idea what the next number will be?


When you specify seeds in simulations, you can replicate the same results, even though you use random numbers. Sometimes the seeds are initialized using the computer’s real time clock, which may provide enough randomness for simulation purposes, but the individual results can not be replicated.


The function random() in most programming languages produces a random number between 0 and 1 according to a uniform distribution. When the underlying sequence of random numbers falls between 0 and M, the random number is divided by M to produce a random number between 0 and 1.


In chapter 5 we will discuss randomness in more detail with various NetLogo models.

##The order of commands
The order in which a program will execute the commands can be important. Suppose I have two agents. Each agent has a money account and the program gives one of the agents 1 dollar. What will happen in each of the following two algorithms?
```
Algorithm 1:

For Agent 1     [Account(t+1) = Account(t) + 1]
For Agent 2 [Account(t+1) = Account(t) + 0]
```
```
Algorithm 2:

Flip a coin. If heads [A = agent 1, B = agent 2] Else [A = agent 2, B = agent 1]

For A [Account(t+1) = Account(t) + 1]
For B [Account(t+1) = Account(t) + 0]
```
